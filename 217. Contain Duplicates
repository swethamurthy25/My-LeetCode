Question :
Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.

Example 1:
Input: nums = [1,2,3,1]
Output: true

Example 2:
Input: nums = [1,2,3,4]
Output: false

Example 3:
Input: nums = [1,1,1,3,3,4,3,2,4,2]
Output: true

**********************************************************************************
Approach 1: Brute Force
Explanation: Use two for loops to compare pairs of integers in the array. Once we reach a comparison in which the numbers are the same, we return true. If we loop through all the integers of the array without reaching a similar pair of numbers, we return false.
Runtime: Time Limit Exceeded
Time Complexity - O(n^2)
Space Complexity - O(1)

# Brute force approach
        
        n = len(nums)
        
        for i in range(n-1):  // this for loop will check for the numbers from 0 to n-1
            for j in range(i+1 , n): // for loop will check for the numbers from 1 to n
                if nums[i] == nums[j]: return True
        return False
        
*******************************************************************************
Approach 2: Sorting the array (Heap Sort)
Explanation: We start off by sorting the given array. Once we loop through the array from the beginning, if we see that the current number is the same as the next one in the array, there contains a duplicate in the array and therefore we return true. If we finish looping and there are no duplicates, we return false.
Runtime: Faster than 15% (715 ms)
Time Complexity - O(nlogn)
Space Complexity - O(1)

def containsDuplicate(self, nums: List[int]) -> bool:
    nums.sort()
    for i in range(len(nums)-1):
        if nums[i] == nums[i+1]: return True
    return False
    
Note: In general, it is not a good practice to modify the input unless it is clear to the caller that the input will be modified.
***********************************************************************

Approach 3: Using Hahmap
Explanation: From Approach #1 we know that search operations is O(n)O(n) in an unsorted array and we did so repeatedly. 
Utilizing a data structure with faster search time will speed up the entire algorithm.
Here we initialize an empty Hash map . When we traverse through each number in array , if the number is not present in hashmap add to it and return False
If the number already exist in hashmap , its an duplicate , so return True
Time COmplexity - O(n) - because we are iterating only once through the for loop. We do search() and insert() operation for n times.
Spac Complexity - O(n) - The space used by a hash table is linear with the number of elements in it.

class Solution:
    def containsDuplicate(self, nums: List[int]) -> bool:
       
        result = {}
        
        for i in nums:
            if i in result: return True
            else:
                result[i] = 1
                
        return False
       
 ************************* END *******************************************
