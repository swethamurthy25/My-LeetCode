Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements 
should be kept the same. Then return the number of unique elements in nums.

Consider the number of unique elements of nums to be k, to get accepted, you need to do the following things:
- Change the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. 
- The remaining elements of nums are not important as well as the size of nums.
- Return k.

Input: nums = [1,1,2]
Output: 2, nums = [1,2,_]
Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

Input: nums = [0,0,1,1,1,2,2,3,3,4]
Output: 5, nums = [0,1,2,3,4,_,_,_,_,_]
Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively.
It does not matter what you leave beyond the returned k (hence they are underscores).

Constraints:
1 <= nums.length <= 3 * 104
-100 <= nums[i] <= 100
nums is sorted in non-decreasing order.
____________________________________________________________________________________________________

Understanding from question:
1. We need to remove the duplicate elements from nums array
2. The resultant nums array should contain only the unique elements , but this removing the duplicate operation should be done in-place without creating any additional 
   arrays.
3. Return the length of nums as output
__________________________________________________________________________________________
Brute force:
- Using python inbuild functions sorted and set

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        nums[:] = sorted(set(nums))
        return len(nums)
        
Here nums[:] = replaces element in place.
Time Complexity: O(n)
Space Complexity: O(1)
_________________________________________________________________________________________________

Optimized solution using two pointer approach:

1. Initialize a left pointer l to 1. The left pointer represents the index where the next unique element should be placed.
2. Using for loop iterate through the list nums using a right pointer r. The right pointer starts from index 1 and goes up to the last index of nums.
3. if nums[r] != nums[r-1]:: Check if the current element at nums[r] is different from the previous element at nums[r-1]. If they are different, it means we have 
encountered a new unique element.
4. nums[l] = nums[r]: Assign the new unique element nums[r] to the next available position at nums[l]. This effectively overwrites any duplicate elements encountered so far.
5. Increment the left pointer l by 1 to indicate that a new unique element has been placed at nums[l].
6. Return the value of l, which represents the count of unique elements.

class Solution:
    def removeDuplicates(self, nums: List[int]) -> int:
        #Two pointer approach
        l = 1
        for r in range(1,len(nums)):
            if nums[r] != nums[r-1]:
                nums[l] = nums[r]
                l += 1
        return l
 
 The time complexity of this code is O(n), where n is the length of the input list nums. 
 The code iterates through the list once using the two-pointer approach,comparing adjacent elements. Since the list is already sorted, the duplicates can be 
 detected by comparing adjacent elements. 

The space complexity is O(1) as the modifications are made in-place within the nums list and only a constant amount of additional space is used.
___________________________________________________________________________________________________________


















