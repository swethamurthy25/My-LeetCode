Given the root of a binary tree, return the preorder traversal of its nodes' values.

Input: root = [1,null,2,3]
Output: [1,2,3]

Input: root = []
Output: []

Input: root = [1]
Output: [1]

Follow up: Recursive solution is trivial, could you do it iteratively?
____________________________________________________________

Depth First search and Recursive:

# Traversal route --> Root , Left and Right ==> [1,2,4,5,3,6,7]

''' Recursive Method: Space - O(N log N)

class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        
        if root is None:
            return []
        return [root.val] + self.preorderTraversal(root.left) + self.preorderTraversal(root.right)

'''
_______________________________________________

Iterative Approach: TC is O(n) and SC is O(1)

Traverse PRE-ORDER, POST ORDER, AND IN-ORDER using Iterative Approach
PRE-ORDER: [Visit Root, Traverser to Left subtree, Traverse to Right subtree]
 	Start with root, so initialize the stack with the root
 	Initialize an empty list to store the result
 	If the root is null: return an empty list
 	When the stack is not empty, pop out the last element from the stack and append it to the result.
 	If the right node is not null, append the value to the stack
 	If the left node is not null, append the value to the stack

            
class Solution:
    def preorderTraversal(self, root: Optional[TreeNode]) -> List[int]:
        stack = [root]
        result = []
        
        if root is None:
            return []
        
        # While stack is not empty , pop last in , first from the stack and append in result
        while stack != []:
            root = stack.pop()
            result.append(root.val)
            if root.right is not None:
                stack.append(root.right)
            if root.left is not None:
                stack.append(root.left)
        return result
           
______________________________________________________________________________


        
        
        
